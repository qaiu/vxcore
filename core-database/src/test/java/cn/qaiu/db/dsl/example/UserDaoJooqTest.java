package cn.qaiu.db.dsl.example;

import cn.qaiu.db.dsl.core.JooqExecutor;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Pool;
import io.vertx.sqlclient.PoolOptions;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * UserDao æµ‹è¯•ç±» - åŸºäºŽ jOOQ DSL
 * 
 * æµ‹è¯•é‡æž„åŽçš„ UserDaoï¼ŒéªŒè¯åŸºäºŽ AbstractDao çš„ CRUD æ“ä½œ
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class UserDaoJooqTest {

    private Vertx vertx;
    private Pool pool;
    private JooqExecutor executor;
    private UserDao userDao;

    @BeforeEach
    void setUp() throws InterruptedException {
        vertx = Vertx.vertx();
        
        // é…ç½® H2 å†…å­˜æ•°æ®åº“ - ä½¿ç”¨JDBCè¿žæŽ¥
        String dbName = "testdb_" + System.currentTimeMillis();
        JDBCConnectOptions connectOptions = new JDBCConnectOptions()
                .setJdbcUrl("jdbc:h2:mem:" + dbName + ";DB_CLOSE_DELAY=-1;MODE=MySQL")
                .setUser("sa")
                .setPassword("");

        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);
        pool = JDBCPool.pool(vertx, connectOptions, poolOptions);
        
        executor = new JooqExecutor(pool);
        userDao = new UserDao(executor);
        
        // åˆå§‹åŒ–æ•°æ®åº“è¡¨
        initDatabase();
    }

    @AfterEach
    void tearDown() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        pool.close()
                .onComplete(v -> {
                    vertx.close()
                            .onComplete(v2 -> latch.countDown());
                });
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    private void initDatabase() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        String createTableSql = "DROP TABLE IF EXISTS dsl_user;" +
                "CREATE TABLE dsl_user (" +
                "id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "username VARCHAR(255) NOT NULL UNIQUE," +
                "email VARCHAR(255) NOT NULL UNIQUE," +
                "password VARCHAR(255) NOT NULL," +
                "age INTEGER," +
                "bio TEXT," +
                "status VARCHAR(50) NOT NULL," +
                "balance DECIMAL(10, 2) DEFAULT 0.00," +
                "email_verified BOOLEAN DEFAULT FALSE," +
                "create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP," +
                "update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP" +
                ");";
        
        executor.executeUpdate(executor.dsl().query(createTableSql))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        System.out.println("Database initialized successfully");
                    } else {
                        System.err.println("Failed to initialize database: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testCreateUser() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("testuser", "test@example.com", "password123")
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        User user = ar.result();
                        assertNotNull(user);
                        assertNotNull(user.getId());
                        assertEquals("testuser", user.getUsername());
                        assertEquals("test@example.com", user.getEmail());
                        assertEquals(User.UserStatus.ACTIVE, user.getStatus());
                        assertEquals(new BigDecimal("100.00"), user.getBalance());
                        assertFalse(user.getEmailVerified());
                        System.out.println("âœ… User created successfully: " + user.getId());
                    } else {
                        fail("Failed to create user: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testFindById() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("finduser", "find@example.com", "password123")
                .compose(createdUser -> userDao.findById(createdUser.getId()))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertTrue(userOpt.isPresent());
                        User user = userOpt.get();
                        assertEquals("finduser", user.getUsername());
                        assertEquals("find@example.com", user.getEmail());
                        System.out.println("âœ… User found by ID: " + user.getId());
                    } else {
                        fail("Failed to find user by ID: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testFindByUsername() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("usernameuser", "username@example.com", "password123")
                .compose(createdUser -> userDao.findByUsername("usernameuser"))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertTrue(userOpt.isPresent());
                        User user = userOpt.get();
                        assertEquals("usernameuser", user.getUsername());
                        assertEquals("username@example.com", user.getEmail());
                        System.out.println("âœ… User found by username: " + user.getUsername());
                    } else {
                        fail("Failed to find user by username: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testFindByEmail() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("emailuser", "email@example.com", "password123")
                .compose(createdUser -> userDao.findByEmail("email@example.com"))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertTrue(userOpt.isPresent());
                        User user = userOpt.get();
                        assertEquals("emailuser", user.getUsername());
                        assertEquals("email@example.com", user.getEmail());
                        System.out.println("âœ… User found by email: " + user.getEmail());
                    } else {
                        fail("Failed to find user by email: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testFindActiveUsers() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> userDao.createUser("active1", "active1@example.com", "password123"))
                .compose(v -> userDao.createUser("active2", "active2@example.com", "password123"))
                .compose(v -> userDao.createUser("inactive", "inactive@example.com", "password123"))
                .compose(v -> {
                    // è®¾ç½®ä¸€ä¸ªç”¨æˆ·ä¸ºéžæ´»è·ƒçŠ¶æ€
                    return userDao.findByUsername("inactive")
                            .compose(userOpt -> {
                                if (userOpt.isPresent()) {
                                    return userDao.updateUserStatus(userOpt.get().getId(), User.UserStatus.INACTIVE);
                                }
                                return Future.succeededFuture(false);
                            });
                })
                .compose(v -> userDao.findActiveUsers())
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> activeUsers = ar.result();
                        assertEquals(2, activeUsers.size());
                        assertTrue(activeUsers.stream().allMatch(u -> u.getStatus() == User.UserStatus.ACTIVE));
                        System.out.println("âœ… Found " + activeUsers.size() + " active users");
                    } else {
                        fail("Failed to find active users: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(10, TimeUnit.SECONDS));
    }

    @Test
    void testUpdatePassword() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("passuser", "pass@example.com", "oldpassword")
                .compose(createdUser -> userDao.updatePassword(createdUser.getId(), "newpassword"))
                .compose(updated -> {
                    assertTrue(updated);
                    return userDao.findById(1L); // å‡è®¾IDæ˜¯1
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        if (userOpt.isPresent()) {
                            User user = userOpt.get();
                            assertEquals("newpassword", user.getPassword());
                            System.out.println("âœ… Password updated successfully");
                        }
                    } else {
                        fail("Failed to update password: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testFindByAgeRange() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> {
                    User user1 = new User();
                    user1.setUsername("age25");
                    user1.setEmail("age25@example.com");
                    user1.setPassword("password");
                    user1.setAge(25);
                    user1.setStatus(User.UserStatus.ACTIVE);
                    return userDao.insert(user1);
                })
                .compose(v -> {
                    User user2 = new User();
                    user2.setUsername("age30");
                    user2.setEmail("age30@example.com");
                    user2.setPassword("password");
                    user2.setAge(30);
                    user2.setStatus(User.UserStatus.ACTIVE);
                    return userDao.insert(user2);
                })
                .compose(v -> {
                    User user3 = new User();
                    user3.setUsername("age35");
                    user3.setEmail("age35@example.com");
                    user3.setPassword("password");
                    user3.setAge(35);
                    user3.setStatus(User.UserStatus.ACTIVE);
                    return userDao.insert(user3);
                })
                .compose(v -> userDao.findByAgeRange(25, 30))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(2, users.size());
                        assertTrue(users.stream().allMatch(u -> u.getAge() >= 25 && u.getAge() <= 30));
                        System.out.println("âœ… Found " + users.size() + " users in age range 25-30");
                    } else {
                        fail("Failed to find users by age range: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(10, TimeUnit.SECONDS));
    }

    @Test
    void testFindByMinBalance() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> {
                    User user1 = new User();
                    user1.setUsername("rich");
                    user1.setEmail("rich@example.com");
                    user1.setPassword("password");
                    user1.setBalance(new BigDecimal("1000.00"));
                    user1.setStatus(User.UserStatus.ACTIVE);
                    return userDao.insert(user1);
                })
                .compose(v -> {
                    User user2 = new User();
                    user2.setUsername("poor");
                    user2.setEmail("poor@example.com");
                    user2.setPassword("password");
                    user2.setBalance(new BigDecimal("50.00"));
                    user2.setStatus(User.UserStatus.ACTIVE);
                    return userDao.insert(user2);
                })
                .compose(v -> userDao.findByMinBalance(new BigDecimal("500.00")))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(1, users.size());
                        assertEquals("rich", users.get(0).getUsername());
                        System.out.println("âœ… Found " + users.size() + " users with balance >= 500.00");
                    } else {
                        fail("Failed to find users by min balance: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(10, TimeUnit.SECONDS));
    }

    @Test
    void testDeleteUser() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("deleteuser", "delete@example.com", "password123")
                .compose(createdUser -> {
                    Long userId = createdUser.getId();
                    return userDao.delete(userId)
                            .compose(deleted -> {
                                assertTrue(deleted);
                                return userDao.findById(userId);
                            });
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertFalse(userOpt.isPresent());
                        System.out.println("âœ… User deleted successfully");
                    } else {
                        fail("Failed to delete user: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }

    @Test
    void testGetUserStatistics() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> userDao.createUser("stats1", "stats1@example.com", "password123"))
                .compose(v -> userDao.createUser("stats2", "stats2@example.com", "password123"))
                .compose(v -> userDao.createUser("stats3", "stats3@example.com", "password123"))
                .compose(v -> userDao.getUserStatistics())
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        JsonObject stats = ar.result();
                        assertTrue(stats.getInteger("totalUsers") >= 3);
                        assertTrue(stats.getInteger("activeUsers") >= 3);
                        assertTrue(stats.getDouble("averageAge") > 0);
                        System.out.println("âœ… User statistics: " + stats.encodePrettily());
                    } else {
                        fail("Failed to get user statistics: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(10, TimeUnit.SECONDS));
    }

    @Test
    void testJooqDslIntegration() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        
        System.out.println("ðŸŽ¯ Testing jOOQ DSL Integration...");
        
        userDao.createUser("jooquser", "jooq@example.com", "password123")
                .compose(createdUser -> {
                    System.out.println("âœ… User created with jOOQ DSL: " + createdUser.getId());
                    
                    // æµ‹è¯•å¤æ‚çš„jOOQ DSLæŸ¥è¯¢
                    return userDao.findByCondition(
                            DSL.field("username").eq("jooquser")
                                    .and(DSL.field("status").eq("ACTIVE"))
                    );
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(1, users.size());
                        assertEquals("jooquser", users.get(0).getUsername());
                        System.out.println("âœ… Complex jOOQ DSL query executed successfully");
                        System.out.println("ðŸŽ¯ jOOQ DSL Integration test completed!");
                    } else {
                        fail("Failed jOOQ DSL integration test: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS));
    }
}
