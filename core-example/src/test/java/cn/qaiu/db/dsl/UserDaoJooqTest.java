package cn.qaiu.db.dsl;

import cn.qaiu.db.dsl.core.JooqExecutor;
import cn.qaiu.example.dao.UserDao;
import cn.qaiu.example.entity.User;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.PoolOptions;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * UserDao æµ‹è¯•ç±» - åŸºäº jOOQ DSL
 * 
 * æµ‹è¯•é‡æ„åçš„ UserDaoï¼ŒéªŒè¯åŸºäº AbstractDao çš„ CRUD æ“ä½œ
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class UserDaoJooqTest {

    private static final Logger logger = LoggerFactory.getLogger(UserDaoJooqTest.class);
    private static final int TEST_TIMEOUT_SECONDS = 10;
    
    private Vertx vertx;
    private JDBCPool pool;
    private JooqExecutor executor;
    private UserDao userDao;

    @BeforeEach
    void setUp() throws InterruptedException {
        logger.info("Setting up test environment...");
        vertx = Vertx.vertx();
        
        // é…ç½® H2 å†…å­˜æ•°æ®åº“ - ä½¿ç”¨JDBCè¿æ¥
        String dbName = "testdb_" + System.currentTimeMillis();
        JDBCConnectOptions connectOptions = new JDBCConnectOptions()
                .setJdbcUrl("jdbc:h2:mem:" + dbName + ";DB_CLOSE_DELAY=-1;MODE=MySQL")
                .setUser("sa")
                .setPassword("");

        PoolOptions poolOptions = new PoolOptions().setMaxSize(5);
        pool = JDBCPool.pool(vertx, connectOptions, poolOptions);
        
        executor = new JooqExecutor(pool);
        userDao = new UserDao(executor);
        
        // åˆå§‹åŒ–æ•°æ®åº“è¡¨
        initDatabase();
        logger.info("Test environment setup completed");
    }

    @AfterEach
    void tearDown() throws InterruptedException {
        logger.info("Tearing down test environment...");
        CountDownLatch latch = new CountDownLatch(1);
        pool.close()
                .onComplete(v -> {
                    vertx.close()
                            .onComplete(v2 -> {
                                logger.info("Test environment cleanup completed");
                                latch.countDown();
                            });
                });
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    private void initDatabase() throws InterruptedException {
        logger.info("Initializing test database...");
        CountDownLatch latch = new CountDownLatch(1);
        
        String createTableSql = """
            DROP TABLE IF EXISTS users;
            CREATE TABLE users (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                username VARCHAR(255) NOT NULL UNIQUE,
                email VARCHAR(255) NOT NULL UNIQUE,
                password VARCHAR(255) NOT NULL,
                age INTEGER,
                bio TEXT,
                status VARCHAR(50) NOT NULL,
                balance DECIMAL(10, 2) DEFAULT 0.00,
                email_verified BOOLEAN DEFAULT FALSE,
                create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            """;
        
        executor.executeUpdate(executor.dsl().query(createTableSql))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        logger.info("Database initialized successfully");
                    } else {
                        logger.error("Failed to initialize database", ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testCreateUser() throws InterruptedException {
        logger.info("Testing user creation...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("testuser", "test@example.com", "password123")
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        User user = ar.result();
                        assertNotNull(user, "User should not be null");
                        assertNotNull(user.getId(), "User ID should not be null");
                        assertEquals("testuser", user.getName());
                        assertEquals("test@example.com", user.getEmail());
                        assertEquals(User.UserStatus.ACTIVE, user.getStatus());
                        assertEquals(new BigDecimal("100.00"), user.getBalance());
                        assertFalse(user.getEmailVerified());
                        logger.info("âœ… User created successfully: {}", user.getId());
                    } else {
                        fail("Failed to create user: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindById() throws InterruptedException {
        logger.info("Testing find user by ID...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("finduser", "find@example.com", "password123")
                .compose(createdUser -> userDao.findById(createdUser.getId()))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertTrue(userOpt.isPresent(), "User should be found");
                        User user = userOpt.get();
                        assertEquals("finduser", user.getName());
                        assertEquals("find@example.com", user.getEmail());
                        logger.info("âœ… User found by ID: {}", user.getId());
                    } else {
                        fail("Failed to find user by ID: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindByUsername() throws InterruptedException {
        logger.info("Testing find user by username...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("usernameuser", "username@example.com", "password123")
                .compose(createdUser -> userDao.findByName("usernameuser"))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertTrue(!users.isEmpty(), "User should be found by username");
                        User user = users.get(0);
                        assertEquals("usernameuser", user.getName());
                        assertEquals("username@example.com", user.getEmail());
                        logger.info("âœ… User found by username: {}", user.getName());
                    } else {
                        fail("Failed to find user by username: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindByEmail() throws InterruptedException {
        logger.info("Testing find user by email...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("emailuser", "email@example.com", "password123")
                .compose(createdUser -> userDao.findOneByEmail("email@example.com"))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertTrue(userOpt.isPresent(), "User should be found by email");
                        User user = userOpt.get();
                        assertEquals("emailuser", user.getName());
                        assertEquals("email@example.com", user.getEmail());
                        logger.info("âœ… User found by email: {}", user.getEmail());
                    } else {
                        fail("Failed to find user by email: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindActiveUsers() throws InterruptedException {
        logger.info("Testing find active users...");
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> userDao.createUser("active1", "active1@example.com", "password123"))
                .compose(v -> userDao.createUser("active2", "active2@example.com", "password123"))
                .compose(v -> userDao.createUser("inactive", "inactive@example.com", "password123"))
                .compose(v -> {
                    // è®¾ç½®ä¸€ä¸ªç”¨æˆ·ä¸ºéæ´»è·ƒçŠ¶æ€
                    return userDao.findByName("inactive")
                            .compose(users -> {
                                if (!users.isEmpty()) {
                                    return userDao.updateUserStatus(users.get(0).getId(), User.UserStatus.INACTIVE);
                                }
                                return Future.succeededFuture(false);
                            });
                })
                .compose(v -> userDao.findActiveUsers())
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> activeUsers = ar.result();
                        assertEquals(2, activeUsers.size(), "Should find 2 active users");
                        assertTrue(activeUsers.stream().allMatch(u -> u.getStatus() == User.UserStatus.ACTIVE),
                                "All found users should be active");
                        logger.info("âœ… Found {} active users", activeUsers.size());
                    } else {
                        fail("Failed to find active users: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testUpdatePassword() throws InterruptedException {
        logger.info("Testing password update...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("passuser", "pass@example.com", "oldpassword")
                .compose(createdUser -> {
                    Long userId = createdUser.getId();
                    return userDao.updatePassword(userId, "newpassword")
                            .compose(updated -> {
                                assertTrue(updated, "Password update should succeed");
                                return userDao.findById(userId);
                            });
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        if (userOpt.isPresent()) {
                            User user = userOpt.get();
                            assertEquals("newpassword", user.getPassword(), "Password should be updated");
                            logger.info("âœ… Password updated successfully");
                        } else {
                            fail("User should be found after password update");
                        }
                    } else {
                        fail("Failed to update password: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindByAgeRange() throws InterruptedException {
        logger.info("Testing find users by age range...");
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> createTestUser("age25", "age25@example.com", 25))
                .compose(v -> createTestUser("age30", "age30@example.com", 30))
                .compose(v -> createTestUser("age35", "age35@example.com", 35))
                .compose(v -> userDao.findByAgeRange(25, 30))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(2, users.size(), "Should find 2 users in age range 25-30");
                        assertTrue(users.stream().allMatch(u -> u.getAge() >= 25 && u.getAge() <= 30),
                                "All users should be in the specified age range");
                        logger.info("âœ… Found {} users in age range 25-30", users.size());
                    } else {
                        fail("Failed to find users by age range: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testFindByMinBalance() throws InterruptedException {
        logger.info("Testing find users by minimum balance...");
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> createTestUserWithBalance("rich", "rich@example.com", new BigDecimal("1000.00")))
                .compose(v -> createTestUserWithBalance("poor", "poor@example.com", new BigDecimal("50.00")))
                .compose(v -> userDao.findByMinBalance(new BigDecimal("500.00")))
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(1, users.size(), "Should find 1 user with balance >= 500.00");
                        assertEquals("rich", users.get(0).getName(), "Should find the rich user");
                        logger.info("âœ… Found {} users with balance >= 500.00", users.size());
                    } else {
                        fail("Failed to find users by min balance: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testDeleteUser() throws InterruptedException {
        logger.info("Testing user deletion...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("deleteuser", "delete@example.com", "password123")
                .compose(createdUser -> {
                    Long userId = createdUser.getId();
                    return userDao.delete(userId)
                            .compose(deleted -> {
                                assertTrue(deleted, "User deletion should succeed");
                                return userDao.findById(userId);
                            });
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        Optional<User> userOpt = ar.result();
                        assertFalse(userOpt.isPresent(), "User should not be found after deletion");
                        logger.info("âœ… User deleted successfully");
                    } else {
                        fail("Failed to delete user: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testGetUserStatistics() throws InterruptedException {
        logger.info("Testing user statistics...");
        CountDownLatch latch = new CountDownLatch(1);
        
        Future.succeededFuture()
                .compose(v -> userDao.createUser("stats1", "stats1@example.com", "password123"))
                .compose(v -> userDao.createUser("stats2", "stats2@example.com", "password123"))
                .compose(v -> userDao.createUser("stats3", "stats3@example.com", "password123"))
                .compose(v -> userDao.getUserStatistics())
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        JsonObject stats = ar.result();
                        assertTrue(stats.getInteger("totalUsers") >= 3, "Should have at least 3 total users");
                        assertTrue(stats.getInteger("activeUsers") >= 3, "Should have at least 3 active users");
                        assertTrue(stats.getDouble("averageAge") > 0, "Average age should be positive");
                        logger.info("âœ… User statistics: {}", stats.encodePrettily());
                    } else {
                        fail("Failed to get user statistics: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }

    @Test
    void testJooqDslIntegration() throws InterruptedException {
        logger.info("ğŸ¯ Testing jOOQ DSL Integration...");
        CountDownLatch latch = new CountDownLatch(1);
        
        userDao.createUser("jooquser", "jooq@example.com", "password123")
                .compose(createdUser -> {
                    logger.info("âœ… User created with jOOQ DSL: {}", createdUser.getId());
                    
                    // æµ‹è¯•å¤æ‚çš„jOOQ DSLæŸ¥è¯¢
                    return userDao.findByCondition(
                            DSL.field("username").eq("jooquser")
                                    .and(DSL.field("status").eq("ACTIVE"))
                    );
                })
                .onComplete(ar -> {
                    if (ar.succeeded()) {
                        List<User> users = ar.result();
                        assertEquals(1, users.size(), "Should find exactly 1 user");
                        assertEquals("jooquser", users.get(0).getName(), "Username should match");
                        logger.info("âœ… Complex jOOQ DSL query executed successfully");
                        logger.info("ğŸ¯ jOOQ DSL Integration test completed!");
                    } else {
                        fail("Failed jOOQ DSL integration test: " + ar.cause());
                    }
                    latch.countDown();
                });
        
        assertTrue(latch.await(TEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));
    }
    
    // =================== è¾…åŠ©æ–¹æ³• ===================
    
    /**
     * åˆ›å»ºæµ‹è¯•ç”¨æˆ·ï¼ˆå¸¦å¹´é¾„ï¼‰
     */
    private Future<Optional<User>> createTestUser(String username, String email, Integer age) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        user.setPassword("password");
        user.setAge(age);
        user.setStatus(User.UserStatus.ACTIVE);
        return userDao.insert(user);
    }
    
    /**
     * åˆ›å»ºæµ‹è¯•ç”¨æˆ·ï¼ˆå¸¦ä½™é¢ï¼‰
     */
    private Future<Optional<User>> createTestUserWithBalance(String username, String email, BigDecimal balance) {
        User user = new User();
        user.setUsername(username);
        user.setEmail(email);
        user.setPassword("password");
        user.setBalance(balance);
        user.setStatus(User.UserStatus.ACTIVE);
        return userDao.insert(user);
    }
}
